# 工程方案结构化写作指南

## 核心观点

写好技术规范文档，"写作能力"不是最关键的。优质文档来自**结构化思维**和**工程实践**。

## 1. 不要从头开始写

技术规范应该是**边实现边记录**的产物，而不是先写好再实现。

### 正确的流程
```
1. 先做原型/实现
2. 遇到设计决策时记录下"为什么"
3. 积累到一定程度后整理成文档
4. 继续实现时补充遗漏的部分
```

### 为什么？
- 实现过程中发现的真实问题才是值得写的
- 空想出来的规范往往有遗漏
- 边做边写，记忆最清晰

---

## 2. 使用结构化模板

技术规范有相对固定的模式，可以直接套用。

### 标准模板

```markdown
# [项目名称] 技术规范

## 1. 概述与目标
- 问题陈述：为什么需要这个
- 设计原则：核心决策准则
- 参考项目：相关开源项目

## 2. 架构
- 整体架构图/层次划分
- 模块职责边界
- 配置方式

## 3. 数据模型
- 核心类型定义
- 数据结构
- 类型之间的关系

## 4. API 设计
- 函数/方法签名
- 参数说明
- 返回值说明
- 使用示例

## 5. 实现细节
- 关键算法流程
- 提供商/平台差异处理
- 边缘情况

## 6. 错误处理
- 错误分类
- 错误层次结构
- 重试策略

## 7. 示例代码
- 基础用法
- 高级用法
- 常见模式

## 8. 验收清单
- 功能完整性检查
- 跨平台同等性验证
- 集成测试用例
```

---

## 3. 用表格替代大段文字

表格是**偷懒但有效**的技巧，特别适合对比差异。

### 示例：提供商差异对比

| 提供商    | 系统消息处理 | 工具调用 ID | 推理令牌 |
|-----------|-------------|------------|---------|
| OpenAI    | `instructions` 参数 | 提供商分配 | `output_tokens_details` |
| Anthropic | `system` 参数 | 提供商分配 | 思考块文本 |
| Gemini    | `systemInstruction` | 无（用函数名） | `thoughtsTokenCount` |

### 表格的优点
- 易于写
- 易于读
- 信息密度高
- 便于后期维护

---

## 4. 代码即文档

### 优先写
- 接口定义（类型、函数签名）
- 伪代码算法流程
- 示例代码

### 示例：用伪代码描述流程

```
FUNCTION tool_loop(request, tools, max_tool_rounds):
    conversation = request.messages
    steps = []

    FOR round_num FROM 0 TO max_tool_rounds:
        response = client.complete(request_with(conversation))
        tool_calls = response.tool_calls

        IF tool_calls:
            tool_results = execute_all_tools(tools, tool_calls)
        ELSE:
            tool_results = []

        IF tool_calls is empty:
            BREAK

        conversation.APPEND(response.message)
        conversation.APPEND(tool_results)

    RETURN result
```

### 为什么有效？
- 代码比自然语言更精确
- 示例比解释更有说服力
- 读者可以直接参考使用

---

## 5. 分阶段写作

不要试图一次写完，采用迭代方式。

### 迭代策略

```
v1：核心数据模型 + 基本API
    - 定义主要类型
    - 列出核心函数
    - 基础示例

v2：添加错误处理
    - 错误分类
    - 错误层次结构
    - 重试策略

v3：添加高级特性
    - 工具调用细节
    - 流式处理
    - 中间件机制

v4：补充细节和附录
    - 更多示例
    - 验收清单
    - 常见问题
```

### 每个版本的交付物
- 可读的文档
- 可用的代码（如果实现了）
- 明确的待办列表

---

## 6. 先写中文，再润色

### 写作流程

1. **初稿**：用最直白的中文把想法写下来
   - 不要纠结措辞
   - 先把内容完整
   - 允许有重复和啰嗦

2. **审阅**：检查内容完整性
   - 是否有遗漏的关键点
   - 逻辑是否通顺
   - 示例是否正确

3. **润色**：改进可读性
   - 统一术语
   - 删除重复
   - 调整结构

### 润色检查清单
- [ ] 术语是否统一
- [ ] 是否有明显的重复
- [ ] 示例代码是否正确
- [ ] 表格是否对齐
- [ ] 链接是否有效

---

## 7. 最实用的一招：边实现边写

写规范的最好时机是**你刚解决完一个棘手问题的时候**。

### 具体做法

解决一个问题后，立即记录：

```markdown
## 问题：[问题标题]

### 背景
- 遇到什么情况
- 为什么这是个问题

### 解决方案
- 采用的方案
- 实现要点
- 代码片段（关键部分）

### 遇到的坑
- 尝试过但失败的方案
- 容易出错的地方
- 需要特别注意的细节

### 相关资料
- 参考文档
- 相关 issues
```

### 为什么有效？
- 记忆最清晰
- 动机最明确
- 内容最真实

---

## 8. 借鉴 AI 辅助

### AI 可以帮你做什么

1. **生成初稿**
   - 你提供要点
   - AI 扩展成完整内容

2. **润色内容**
   - 改进表达
   - 统一术语
   - 调整结构

3. **检查遗漏**
   - 询问"这个规范还缺少什么"
   - 让 AI 提供补充建议

4. **生成示例**
   - 根据规范生成使用示例
   - 生成测试用例

### 使用示例

```
你：基于这份 LLM 客户端规范，帮我写一个简化版的
     Python 实现计划，只关注核心功能

AI：会输出一个结构化的实现计划
```

---

## 9. 结构化写作技巧

### 使用标记和格式

```markdown
# 一级标题：主要章节
## 二级标题：子章节
### 三级标题：具体主题

**加粗**：强调关键词
`代码`：术语、参数名

> 引用块：重要提示

- 列表项：并列内容
1. 编号列表：步骤顺序
```

### 信息块模式

对于可复用的内容块，使用统一的格式：

```markdown
### [内容块标题]

**为什么**：解释原因
**怎么做**：具体步骤
**示例**：代码示例
**注意**：需要特别说明的点
```

---

## 10. 完成定义

文档的最后一部分应该是验收清单。

### 验收清单模板

```markdown
## 完成定义

### 核心功能
- [ ] 功能 A 实现并测试
- [ ] 功能 B 实现并测试
- [ ] 功能 C 实现并测试

### 文档完整性
- [ ] 所有 API 都有文档
- [ ] 所有类型都有说明
- [ ] 提供足够的使用示例

### 兼容性验证
| 平台    | 测试状态 |
|---------|---------|
| 平台 A  | [ ]      |
| 平台 B  | [ ]      |
| 平台 C  | [ ]      |

### 集成测试
- [ ] 端到端测试通过
- [ ] 边缘情况覆盖
- [ ] 错误处理验证
```

---

## 总结

### 核心原则

1. **边做边写**：不要空想，在实践中记录
2. **先完整后完美**：先把内容写全，再润色
3. **用代码说话**：示例比长篇解释更有用
4. **善用工具**：表格、模板、AI 都能帮你提高效率

### 心态调整

- 你不需要"写作好"，你需要的是"想清楚"
- 技术文档的"写作"本质是**整理工程决策**
- 如果你做对了这些决策，文档只是把它们记录下来

### 行动建议

从今天开始：
1. 选一个你正在做的项目
2. 创建一个 `docs/spec.md` 文件
3. 每解决一个问题，就记录一条
4. 坚持一个月，你会看到成果
